<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Pebble SDK: Graphics Types</title>
  <link href='bootstrap.css' media='screen' rel='stylesheet' type='text/css' />
  <link href='pebble-developer.css' media='screen' rel='stylesheet' type='text/css' />
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
  <link href="stylesheet.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-30638158-4']);
    _gaq.push(['_trackPageview']);
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</head>
<body>
  <div id="top" ><!-- do not remove this div, it is closed by doxygen! -->
    <div class="navbar navbar-inverse ">
      <div class="navbar-inner">
        <div class="container">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li><a class="first" href="#"><span></span></a></li>
              <li><a href="http://developer.getpebble.com/">Develop for Pebble</a></li>
            </ul>
            <ul class="nav pull-right">
              <li class="doc-nav-searchbox">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</li>
              <li><a href="http://forums.getpebble.com/">Forum</a></li>
              <li><a href="http://developer.getpebble.com/2/api-reference/modules.html">API Documentation</a></li>
              <li><a href="http://developer.getpebble.com/2/">Guides</a></li>
              <li><a href="http://developer.getpebble.com/blog/">Developer Blog</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___graphics_types.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">Graphics Types<div class="ingroups"><a class="el" href="group___graphics.html">Graphics</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Basic graphics types (point, rect, size, color, bitmaps, etc.) and utility functions. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___color_definitions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___color_definitions.html">Color Definitions</a></td></tr>
<tr class="memdesc:group___color_definitions"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of all of the named colors available with links to the color map on the Pebble Developer website. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5d86515990747e47a76c0a16ed6b2850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_as_sub_bitmap </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>base_bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>&#160;</td>
          <td class="paramname"><em>sub_rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new GBitmap on the heap as a sub-bitmap of a 'base' GBitmap, using a <a class="el" href="group___graphics_types.html#struct_g_rect" title="Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size...">GRect</a> to indicate what portion of the base to use. The sub-bitmap will just reference the image data and palette of the base bitmap. No deep-copying occurs as a result of calling this function, thus the caller is responsible for making sure the base bitmap and palette will remain available when using the sub-bitmap. Note that you should not destroy the parent bitmap until the sub_bitmap has been destroyed. The resulting GBitmap must be destroyed using <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base_bitmap</td><td>The bitmap that the sub-bitmap of which the image data will be used by the sub-bitmap </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sub_rect</td><td>The rectangle within the image data of the base bitmap. The bounds of the base bitmap will be used to clip <code>sub_rect</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="gaa300cd8eadcfe00bd05c3b1eebf22687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_blank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new blank GBitmap on the heap initialized to zeroes. In the case that the format indicates a palettized bitmap, a palette of appropriate size will also be allocated on the heap. The resulting GBitmap must be destroyed using <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The Pebble image dimensions as a <a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>. </td></tr>
    <tr><td class="paramname">format</td><td>The <a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> the created image should be in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="gaaecee8293ad845287bd4e1d90bc55782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_blank_with_palette </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GColor *&#160;</td>
          <td class="paramname"><em>palette</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new blank GBitmap on the heap, initialized to zeroes, and assigns it the given palette. No deep-copying of the palette occurs, so the caller is responsible for making sure the palette remains available when using the resulting bitmap. Management of that memory can be handed off to the system with the free_on_destroy argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The Pebble image dimensions as a <a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>. </td></tr>
    <tr><td class="paramname">format</td><td>the <a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> the created image and palette should be in. </td></tr>
    <tr><td class="paramname">palette</td><td>a pointer to a palette that is to be used for this GBitmap. The palette should be large enough to hold enough colors for the specified format. For example, GBitmapFormat2BitPalette should have 4 colors, since 2^2 = 4. </td></tr>
    <tr><td class="paramname">free_on_destroy</td><td>Set whether the palette data should be freed along with the bitmap data when the GBitmap is destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ab3b20588760558364911972b7db142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_from_png_data </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>png_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_memory.html#ga7b60c5629e55e8ec87a4547dd4abced4">size_t</a>&#160;</td>
          <td class="paramname"><em>png_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a GBitmap based on raw PNG data. The resulting GBitmap must be destroyed using <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. The developer is responsible for freeing png_data following this call. </p>
<dl class="section note"><dt>Note</dt><dd>PNG decoding currently supports 1,2,4 and 8 bit palettized and grayscale images. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">png_data</td><td>PNG image data. </td></tr>
    <tr><td class="paramname">png_data_size</td><td>PNG image size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4f0e7cfe57c24bf2d2bb80e08ed6ad6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_palettized_from_1bit </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>src_bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a 1-bit GBitmap, create a new bitmap of format GBitmapFormat1BitPalette. The new data buffer is allocated on the heap, and a 2-color palette is allocated as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_bitmap</td><td>A GBitmap of format GBitmapFormat1Bit which is to be copied into a newly created GBitmap of format GBitmapFormat1BitPalettized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created 1-bit palettized GBitmap, or NULL if there is not sufficient space. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The new bitmap does not depend on any data from src_bitmap, so src_bitmap can be freed without worry. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c01fd1816c6c0fde05310141f293cc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_with_data </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new GBitmap on the heap initialized with the provided Pebble image data. </p>
<p>The resulting GBitmap must be destroyed using <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a> but the image data will not be freed automatically. The developer is responsible for keeping the image data in memory as long as the bitmap is used and releasing it after the bitmap is destroyed. </p>
<dl class="section note"><dt>Note</dt><dd>One way to generate Pebble image data is to use bitmapgen.py in the Pebble SDK to generate a .pbi file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The Pebble image data. Must not be NULL. The function assumes the data to be correct; there are no sanity checks performed on the data. The data will not be copied and the pointer must remain valid for the lifetime of this GBitmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="gae1c7c90641f5138b5f36f9334d52085a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_with_resource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>resource_id</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new GBitmap on the heap using a Pebble image file stored as a resource. The resulting GBitmap must be destroyed using <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource_id</td><td>The ID of the bitmap resource to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b0540c1de9ecadbef44e7d87e05ca92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_destroy </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a GBitmap. This must be called for every bitmap that's been created with gbitmap_create_*. </p>
<p>This function will also free the memory of the bitmap data (bitmap-&gt;addr) if the bitmap was created with <a class="el" href="group___graphics_types.html#gaa300cd8eadcfe00bd05c3b1eebf22687">gbitmap_create_blank()</a> or <a class="el" href="group___graphics_types.html#gae1c7c90641f5138b5f36f9334d52085a">gbitmap_create_with_resource()</a>.</p>
<p>If the GBitmap was created with <a class="el" href="group___graphics_types.html#ga0c01fd1816c6c0fde05310141f293cc5">gbitmap_create_with_data()</a>, you must release the memory after calling <a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92" title="Destroy a GBitmap. This must be called for every bitmap that&#39;s been created with gbitmap_create_*. ">gbitmap_destroy()</a>. </p>

</div>
</div>
<a class="anchor" id="gafce95e410fee76c66526f167c8415f3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> gbitmap_get_bounds </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the bounds of the content for the GBitmap. This is set when loading the image or if changed by <a class="el" href="group___graphics_types.html#ga3ef230f384923b9d02b735ac7c0aa7e4">gbitmap_set_bounds</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to get the bounding box from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bounding box for the GBitmap. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#ga3ef230f384923b9d02b735ac7c0aa7e4">gbitmap_set_bounds</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga032629d36d12d13aadfd5176fd0463c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a> gbitmap_get_bytes_per_row </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes per row in the bitmap data for the given GBitmap. This can be used as a safe way of iterating over the rows in the bitmap, since bytes per row should be set according to format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to get the bytes per row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes per row of the GBitmap </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#gacb0f0a071e491d8e96be6bc8ccb921cf">gbitmap_get_data</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacb0f0a071e491d8e96be6bc8ccb921cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* gbitmap_get_data </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the raw image data section of the given GBitmap as specified by the format of the bitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to get the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the raw image data for the GBitmap </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#ga032629d36d12d13aadfd5176fd0463c8">gbitmap_get_bytes_per_row</a> </dd>
<dd>
GBitmap </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c8c92415f93744d2a5aec9cb40194c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> gbitmap_get_format </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> for the GBitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to get the format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The format of the given GBitmap. </dd></dl>

</div>
</div>
<a class="anchor" id="ga89a2945409ae7b2485a1b509dfc1333e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GColor* gbitmap_get_palette </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the palette for the given GBitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to get the palette from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a GColor array containing the palette colors. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#ga4450b2f567703a3e27bcbb51117aa087">gbitmap_set_palette</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dba771fd88df27504b17e4bc2b08d64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmapSequence* gbitmap_sequence_create_with_resource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>resource_id</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a GBitmapSequence from the specified resource (APNG/PNG files) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource_id</td><td>Resource to load and create GBitmapSequence from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GBitmapSequence pointer if the resource was loaded, NULL otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga80e569d755b657753e3508db7f3738ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_sequence_destroy </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the GBitmapSequence structure and frees any allocated memory/decoder_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to the bitmap sequence to free (delete) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0f780293a25c9533e3a7f225e5e32110"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___graphics_types.html#struct_g_size">GSize</a> gbitmap_sequence_get_bitmap_size </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the minimum required size (dimensions) necessary to render the bitmap sequence to a GBitmap using the /ref gbitmap_sequence_update_bitmap_next_frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dimensions required to render the bitmap sequence to a GBitmap </dd></dl>

</div>
</div>
<a class="anchor" id="ga310e83ec73f9bf4615be74f70875bb14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t gbitmap_sequence_get_current_frame_idx </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current frame number for the bitmap sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of current frame in the current loop of the bitmap sequence </dd></dl>

</div>
</div>
<a class="anchor" id="ga9043176bcb76648ea06178359cf49956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> gbitmap_sequence_get_play_count </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the play count (number of times to repeat) the bitmap sequence. </p>
<dl class="section note"><dt>Note</dt><dd>This value is initialized by the bitmap sequence data, and is modified by <a class="el" href="group___graphics_types.html#gaccb2389a62d110a0b36c05fec3026b45">gbitmap_sequence_set_play_count</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Play count of bitmap sequence, PLAY_COUNT_INFINITE for infinite looping </dd></dl>

</div>
</div>
<a class="anchor" id="ga2baea5c5caff4c96de103895e63e66e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> gbitmap_sequence_get_total_num_frames </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the total number of frames for the bitmap sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of frames contained in a single loop of the bitmap sequence </dd></dl>

</div>
</div>
<a class="anchor" id="ga38f7d5f9f91c51ba1735ff570ee83f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gbitmap_sequence_restart </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restarts the GBitmapSequence to the first frame <a class="el" href="group___graphics_types.html#ga0f7029b68fc5f0b6a8869a0aa7717fdc">gbitmap_sequence_update_bitmap_next_frame</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sequence was restarted, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gaccb2389a62d110a0b36c05fec3026b45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_sequence_set_play_count </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>play_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the play count (number of times to repeat) the bitmap sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
    <tr><td class="paramname">play_count</td><td>Number of times to repeat the bitmap sequence with 0 disabling update_by_elapsed and update_next_frame, and PLAY_COUNT_INFINITE for infinite looping of the animation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7c9b86d6acd020cbe4982d00cfd80ff6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gbitmap_sequence_update_bitmap_by_elapsed </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>elapsed_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the contents of the bitmap sequence to the frame at elapsed in the sequence. For looping animations this accounts for the loop, for example an animation of 1 second that is configured to loop 2 times updated to 1500 ms elapsed time will display the sequence frame at 500 ms. Elapsed time is the time from the start of the animation, and will be ignored if it is for a time earlier than the last rendered frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
    <tr><td class="paramname">bitmap</td><td>Pointer to the initialized GBitmap in which to render the bitmap sequence </td></tr>
    <tr><td class="paramname">elapsed_ms</td><td>Elapsed time in milliseconds in the sequence relative to start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a frame was rendered. False if all frames (and loops) have already been rendered for the sequence. Will also return false if frame could not be rendered (includes out of memory errors). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>GBitmap must be large enough to accommodate the bitmap_sequence image <a class="el" href="group___graphics_types.html#ga0f780293a25c9533e3a7f225e5e32110">gbitmap_sequence_get_bitmap_size</a> </dd>
<dd>
This function is disabled for play_count 0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f7029b68fc5f0b6a8869a0aa7717fdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gbitmap_sequence_update_bitmap_next_frame </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> *&#160;</td>
          <td class="paramname"><em>delay_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the contents of the bitmap sequence to the next frame and optionally returns the delay in milliseconds until the next frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bitmap</td><td>Pointer to the initialized GBitmap in which to render the bitmap sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delay_ms</td><td>If not NULL, returns the delay in milliseconds until the next frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if frame was rendered. False if all frames (and loops) have been rendered for the sequence. Will also return false if frame could not be rendered (includes out of memory errors). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>GBitmap must be large enough to accommodate the bitmap_sequence image <a class="el" href="group___graphics_types.html#ga0f780293a25c9533e3a7f225e5e32110">gbitmap_sequence_get_bitmap_size</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ef230f384923b9d02b735ac7c0aa7e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_set_bounds </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bounds of the given GBitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to set the bounding box. </td></tr>
    <tr><td class="paramname">bounds</td><td>The bounding box to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#gafce95e410fee76c66526f167c8415f3f">gbitmap_get_bounds</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga64f2a0d2488f425a710864e127d1d327"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_set_data </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a>&#160;</td>
          <td class="paramname"><em>row_size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bitmap data for the given GBitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to set data to </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the bitmap data </td></tr>
    <tr><td class="paramname">format</td><td>the format of the bitmap data. If this is a palettized format, make sure that there is an accompanying call to <a class="el" href="group___graphics_types.html#ga4450b2f567703a3e27bcbb51117aa087">gbitmap_set_palette</a>. </td></tr>
    <tr><td class="paramname">row_size_bytes</td><td>How many bytes a single row takes. For example, bitmap data of format GBitmapFormat1Bit must have a row size as a multiple of 4 bytes. </td></tr>
    <tr><td class="paramname">free_on_destroy</td><td>Set whether the data should be freed when the GBitmap is destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4450b2f567703a3e27bcbb51117aa087"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_set_palette </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GColor *&#160;</td>
          <td class="paramname"><em>palette</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the palette for the given GBitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to set the palette to </td></tr>
    <tr><td class="paramname">palette</td><td>The palette to be used. Make sure that the palette is large enough for the bitmap's format. </td></tr>
    <tr><td class="paramname">free_on_destroy</td><td>Set whether the palette data should be freed when the GBitmap is destroyed or when another palette is set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics_types.html#ga3c8c92415f93744d2a5aec9cb40194c8">gbitmap_get_format</a> </dd>
<dd>
<a class="el" href="group___graphics_types.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy</a> </dd>
<dd>
<a class="el" href="group___graphics_types.html#ga4450b2f567703a3e27bcbb51117aa087">gbitmap_set_palette</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga40df0077888f77ac5b0a07d8d7304a76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gcolor_equal </td>
          <td>(</td>
          <td class="paramtype">GColor8&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GColor8&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison function for GColors. </p>

</div>
</div>
<a class="anchor" id="ga5d02d53f14eef571f131c784a1eaf3c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GColor8 gcolor_legible_over </td>
          <td>(</td>
          <td class="paramtype">GColor8&#160;</td>
          <td class="paramname"><em>background_color</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method assists in improving the legibility of text on various background colors. It takes the background color for the region in question and computes a color for maximum legibility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">background_color</td><td>Background color for the region in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A legible color for the given background color </dd></dl>

</div>
</div>
<a class="anchor" id="ga55941ba733d6b685ba3fcd316ce12af0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gpoint_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a> *const&#160;</td>
          <td class="paramname"><em>point_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a> *const&#160;</td>
          <td class="paramname"><em>point_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether 2 points are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_a</td><td>Pointer to the first point </td></tr>
    <tr><td class="paramname">point_b</td><td>Pointer to the second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both points are equal, <code>false</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gad714d5d1dd0509196d8aadbdba2ac510"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void grect_align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *&#160;</td>
          <td class="paramname"><em>inside_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#gac8aa0eb3d3065fde8d2d6f282fa47f6a">GAlign</a>&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns one rectangle within another rectangle, using an alignment parameter. The relative coordinate systems of both rectangles are assumed to be the same. When clip is true, <code>rect</code> is also clipped by the constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rect</td><td>The rectangle to align (in place) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rect</td><td>The aligned and optionally clipped rectangle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inside_rect</td><td>The rectangle in which to align <code>rect</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alignment</td><td>Determines the alignment of <code>rect</code> within <code>inside_rect</code> by specifying what edges of should overlap. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">clip</td><td>Determines whether <code>rect</code> should be trimmed using the edges of <code>inside_rect</code> in case <code>rect</code> extends outside of the area that <code>inside_rect</code> covers after the alignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae3a0a9c97927d0a72f3c5d8340e950fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a> grect_center_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to compute the center-point of a given rectangle. This is equal to <code>(rect-&gt;x + rect-&gt;width / 2, rect-&gt;y + rect-&gt;height / 2)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle for which to calculate the center point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The point at the center of <code>rect</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0be9e99bf608e20c4ce33c48a859efa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void grect_clip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_to_clip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_clipper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim one rectangle using the edges of a second rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rect_to_clip</td><td>The rectangle that needs to be clipped (in place). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rect_to_clip</td><td>The clipped rectangle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rect_clipper</td><td>The rectangle of which the edges will serve as "scissors" in order to trim <code>rect_to_clip</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8952ac950ca4ec1195106e7b208a82c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grect_contains_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a> *&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether a rectangle contains a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle </td></tr>
    <tr><td class="paramname">point</td><td>The point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rectangle contains the point, or <code>false</code> if it does not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45ade8bcee6668a5b9fc3a5dc2adbb4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> grect_crop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>crop_size_px</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the width and height of a rectangle by insetting each of the edges with a fixed inset. The returned rectangle will be centered relative to the input rectangle. </p>
<dl class="section note"><dt>Note</dt><dd>The function will trip an assertion if the crop yields a rectangle with negative width or height. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle that will be inset </td></tr>
    <tr><td class="paramname">crop_size_px</td><td>The inset by which each of the rectangle will be inset. A positive inset value results in a smaller rectangle, while negative inset value results in a larger rectangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cropped rectangle. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4bfb1da25ab4fec1a84ffbc50a40bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grect_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether 2 rectangles are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect_a</td><td>Pointer to the first rectangle </td></tr>
    <tr><td class="paramname">rect_b</td><td>Pointer to the second rectangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both rectangles are equal, <code>false</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbece2417a145e398e6c1ce512203150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grect_is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the size of the rectangle is (0, 0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>Pointer to the rectangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rectangle its size is (0, 0), or <code>false</code> if not. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the width and/or height of a rectangle is negative, this function will return <code>true</code>! </dd></dl>

</div>
</div>
<a class="anchor" id="ga6fcd8b24daede67494e49fa4803760a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void grect_standardize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a rectangle's values so that the components of its size (width and/or height) are both positive. In the width and/or height are negative, the origin will offset, so that the final rectangle overlaps with the original. For example, a <a class="el" href="group___graphics_types.html#struct_g_rect" title="Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size...">GRect</a> with size (-10, -5) and origin (20, 20), will be standardized to size (10, 5) and origin (10, 15). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rect</td><td>The rectangle to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rect</td><td>The standardized rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga182655c93aaff5c2df45aba496c64b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gsize_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_size">GSize</a> *&#160;</td>
          <td class="paramname"><em>size_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___graphics_types.html#struct_g_size">GSize</a> *&#160;</td>
          <td class="paramname"><em>size_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether 2 sizes are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_a</td><td>Pointer to the first size </td></tr>
    <tr><td class="paramname">size_b</td><td>Pointer to the second size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both sizes are equal, <code>false</code> if not. </dd></dl>

</div>
</div>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_g_point" id="struct_g_point"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GPoint</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents a point in a 2-dimensional coordinate system. </p>
<dl class="section note"><dt>Note</dt><dd>Conventionally, the origin of Pebble's 2D coordinate system is in the upper, lefthand corner its x-axis extends to the right and its y-axis extends to the bottom of the screen. </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1f1a9ce775dde3448a265dc36b2024f4"></a>int16_t</td>
<td class="fieldname">
x</td>
<td class="fielddoc">
The x-coordinate. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a94afc39fa39df567b9e78702d1f07b3e"></a>int16_t</td>
<td class="fieldname">
y</td>
<td class="fielddoc">
The y-coordinate. </td></tr>
</table>

</div>
</div>
<a name="struct_g_rect" id="struct_g_rect"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GRect</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a28af4b04e081517f4f546c4af5b44612"></a><a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a></td>
<td class="fieldname">
origin</td>
<td class="fielddoc">
The coordinate of the upper-lefthand corner point of the rectangle. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="acd904b1a13b264f257827a295d2d208e"></a><a class="el" href="group___graphics_types.html#struct_g_size">GSize</a></td>
<td class="fieldname">
size</td>
<td class="fielddoc">
The size of the rectangle. </td></tr>
</table>

</div>
</div>
<a name="struct_g_size" id="struct_g_size"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct GSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents a 2-dimensional size. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="acb2d7af62d2615276d4776aa3a2ea0ca"></a>int16_t</td>
<td class="fieldname">
h</td>
<td class="fielddoc">
The height. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab4b00bc79cc43d5554d19fd273fe37e0"></a>int16_t</td>
<td class="fieldname">
w</td>
<td class="fielddoc">
The width. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gac8aa0eb3d3065fde8d2d6f282fa47f6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___graphics_types.html#gac8aa0eb3d3065fde8d2d6f282fa47f6a">GAlign</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values to specify how two things should be aligned relative to each other. </p>
<div class="image">
<img src="galign.png" alt="galign.png"/>
<div class="caption">
.</div></div>
 </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___bitmap_layer.html#ga4c1765f9330890641c4c09ba7e894894">bitmap_layer_set_alignment()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa51bd2083cb00987d9e770436985642b2"></a>GAlignCenter</em>&nbsp;</td><td class="fielddoc">
<p>Align by centering. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aae47b90e410e218b1035083f7d6df8371"></a>GAlignTopLeft</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the top edges overlap and left edges overlap. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aaa6582295979f7c0661f6b5c686a5a606"></a>GAlignTopRight</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the top edges overlap and left edges overlap. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa2791f2177d74ec6baf029a8e25f731d9"></a>GAlignTop</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the top edges overlap and centered horizontally. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aab6fc58bfb9c295f87bee0e6d77b4d683"></a>GAlignLeft</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the left edges overlap and centered vertically. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa0e09ed4f51fd1f8b81205a61405b6eeb"></a>GAlignBottom</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the bottom edges overlap and centered horizontally. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa91754028af85b5079e59025bc13bc021"></a>GAlignRight</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the right edges overlap and centered vertically. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aab7802cc31f96f00cc88cc9d9fd3d8467"></a>GAlignBottomRight</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the bottom edges overlap and right edges overlap. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa0d082bc1a280106ce0c8ce60508ed44d"></a>GAlignBottomLeft</em>&nbsp;</td><td class="fielddoc">
<p>Align by making the bottom edges overlap and left edges overlap. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga5c29b6b52478182a01ec4863de80ebfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___graphics_types.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The format of a GBitmap can either be 1-bit or 8-bit. </p>

</div>
</div>
<a class="anchor" id="ga0d021422bd90a2a49e6c8d848e6d556f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___graphics_types.html#ga0d021422bd90a2a49e6c8d848e6d556f">GCompOp</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values to specify how the source image should be composited onto the destination image. </p>
<p>For Aplite, there is no notion of "transparency" in the graphics system. However, the effect of transparency can be created by masking and using compositing modes. </p>
<div class="image">
<img src="compops.png" alt="compops.png"/>
</div>
<p> Contrived example of how the different compositing modes affect drawing. Often, the "destination image" is the render buffer and thus contains the image of what has been drawn before or "underneath".</p>
<p>For Basalt, at the moment, only two compositing modes are supported, <a class="el" href="group___graphics_types.html#gga0d021422bd90a2a49e6c8d848e6d556fa3d668fac5e660241746c082d7155e059">GCompOpAssign</a> and <a class="el" href="group___graphics_types.html#gga0d021422bd90a2a49e6c8d848e6d556fa3ca84b5c70798643a3bd07b263c47fe6">GCompOpSet</a>. The behavior of other compositing modes are undefined and may change in the future. Transparency can be achieved using <a class="el" href="group___graphics_types.html#gga0d021422bd90a2a49e6c8d848e6d556fa3ca84b5c70798643a3bd07b263c47fe6">GCompOpSet</a> and requires pixel values with alpha value .a &lt; 3. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___bitmap_layer.html#ga7bc761ca8227881c5853cbc0e279385e">bitmap_layer_set_compositing_mode()</a> </dd>
<dd>
<a class="el" href="group___graphics_context.html#ga64bc6cc5f86dabcd4b3cfa9fcffa328c">graphics_context_set_compositing_mode()</a> </dd>
<dd>
<a class="el" href="group___drawing.html#ga2df0bc47f542ea60500d3070670725f9">graphics_draw_bitmap_in_rect()</a> </dd>
<dd>
<a class="el" href="group___drawing.html#ga34f27bdfadc25a04b7b49d5cd8011266">graphics_draw_rotated_bitmap()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556fa3d668fac5e660241746c082d7155e059"></a>GCompOpAssign</em>&nbsp;</td><td class="fielddoc">
<p>Assign the pixel values of the source image to the destination pixels, effectively replacing the previous values for those pixels. For Basalt, when drawing a color palettized or 8-bit GBitmap image, the opacity value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556fa1ee43eff5811f9066ee8a94498e7d828"></a>GCompOpAssignInverted</em>&nbsp;</td><td class="fielddoc">
<p>Assign the <b>inverted</b> pixel values of the source image to the destination pixels, effectively replacing the previous values for those pixels. </p>
<dl class="section note"><dt>Note</dt><dd>For Basalt, this mode is not supported and the resulting behavior is undefined. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556fa30d689e91f2ce16dd949b4076fb76ce4"></a>GCompOpOr</em>&nbsp;</td><td class="fielddoc">
<p>Use the boolean operator <code>OR</code> to composite the source and destination pixels. The visual result of this compositing mode is the source's white pixels are painted onto the destination and the source's black pixels are treated as clear. </p>
<dl class="section note"><dt>Note</dt><dd>For Basalt, this mode is not supported and the resulting behavior is undefined. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556fa0859125379c8687a92843a6db44fb7a6"></a>GCompOpAnd</em>&nbsp;</td><td class="fielddoc">
<p>Use the boolean operator <code>AND</code> to composite the source and destination pixels. The visual result of this compositing mode is the source's black pixels are painted onto the destination and the source's white pixels are treated as clear. </p>
<dl class="section note"><dt>Note</dt><dd>For Basalt, this mode is not supported and the resulting behavior is undefined. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556faba6dadf20ebce8ba4c25ecf3c9a39142"></a>GCompOpClear</em>&nbsp;</td><td class="fielddoc">
<p>Clears the bits in the destination image, using the source image as mask. The visual result of this compositing mode is that for the parts where the source image is white, the destination image will be painted black. Other parts will be left untouched. </p>
<dl class="section note"><dt>Note</dt><dd>For Basalt, this mode is not supported and the resulting behavior is undefined. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0d021422bd90a2a49e6c8d848e6d556fa3ca84b5c70798643a3bd07b263c47fe6"></a>GCompOpSet</em>&nbsp;</td><td class="fielddoc">
<p>Sets the bits in the destination image, using the source image as mask. For Aplite, the visual result of this compositing mode is that for the parts where the source image is black, the destination image will be painted white. Other parts will be left untouched. For Basalt, when drawing a color palettized or 8-bit GBitmap image, this mode will be required to apply any transparency. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga8cb8f728e01e63674935d7601f438841"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COLOR_FALLBACK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">color, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bw&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(color)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro allowing use of a fallback color for black and white platforms. On color platforms this defaults to color. </p>

</div>
</div>
<a class="anchor" id="ga3c778a69b007e2dd2aeb2a8253d2a3ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GColorFromHEX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v)</td><td></td>
          <td>&#160;&#160;&#160;<a class="el" href="group___graphics_types.html#ga5526fda29291b139ceb4c736f7aa61e4">GColorFromRGB</a>(((v) &gt;&gt; 16) &amp; 0xff, ((v) &gt;&gt; 8) &amp; 0xff, ((v) &amp; 0xff))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert hex integer to GColor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Integer hex value (e.g. 0x64ff46) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GColor created from the hex value </dd></dl>

</div>
</div>
<a class="anchor" id="ga5526fda29291b139ceb4c736f7aa61e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GColorFromRGB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">red, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">green, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group___graphics_types.html#gaa7922ac35d2b7fd40547083eed4ed757">GColorFromRGBA</a>(red, green, blue, 255)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert RGB to GColor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">red</td><td>Red value from 0 - 255 </td></tr>
    <tr><td class="paramname">green</td><td>Green value from 0 - 255 </td></tr>
    <tr><td class="paramname">blue</td><td>Blue value from 0 - 255 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GColor created from the RGB values </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7922ac35d2b7fd40547083eed4ed757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GColorFromRGBA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">red, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">green, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alpha&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((GColor8){ \</div>
<div class="line">  .a = (uint8_t)(alpha) &gt;&gt; 6, \</div>
<div class="line">  .r = (uint8_t)(red) &gt;&gt; 6, \</div>
<div class="line">  .g = (uint8_t)(green) &gt;&gt; 6, \</div>
<div class="line">  .b = (uint8_t)(blue) &gt;&gt; 6, \</div>
<div class="line">  })</div>
</div><!-- fragment -->
<p>Convert RGBA to GColor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">red</td><td>Red value from 0 - 255 </td></tr>
    <tr><td class="paramname">green</td><td>Green value from 0 - 255 </td></tr>
    <tr><td class="paramname">blue</td><td>Blue value from 0 - 255 </td></tr>
    <tr><td class="paramname">alpha</td><td>Alpha value from 0 - 255 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GColor created from the RGB values </dd></dl>

</div>
</div>
<a class="anchor" id="gabf9cee451faac8ad07157b775b951699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a>){(x), (y)})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_point" title="Represents a point in a 2-dimensional coordinate system. ">GPoint</a>. </p>

</div>
</div>
<a class="anchor" id="ga24192f6809de17d816671a1d6a7b59b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPointZero&#160;&#160;&#160;<a class="el" href="group___graphics_types.html#struct_g_point">GPoint</a>(0, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_point" title="Represents a point in a 2-dimensional coordinate system. ">GPoint</a> at (0, 0). </p>

</div>
</div>
<a class="anchor" id="ga98a870072d31f765cbfaebe222d85f6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">w, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>){{(x), (y)}, {(w), (h)}})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_rect" title="Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size...">GRect</a>. </p>

</div>
</div>
<a class="anchor" id="ga1d67ac54b909f89dfd99e52eb1a7c0bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GRectZero&#160;&#160;&#160;<a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>(0, 0, 0, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_rect" title="Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size...">GRect</a> of ((0, 0), (0, 0)). </p>

</div>
</div>
<a class="anchor" id="ga71761014e71575ac39edc38709cc048b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group___graphics_types.html#struct_g_size">GSize</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">w, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>){(w), (h)})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_size" title="Represents a 2-dimensional size. ">GSize</a>. </p>

</div>
</div>
<a class="anchor" id="ga7b5e385c855d8c9ad59209816f62b808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GSizeZero&#160;&#160;&#160;<a class="el" href="group___graphics_types.html#struct_g_size">GSize</a>(0, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to make a <a class="el" href="group___graphics_types.html#struct_g_size" title="Represents a 2-dimensional size. ">GSize</a> of (0, 0). </p>

</div>
</div>
<a class="anchor" id="gace600ef49d59abf22dbaad7b5018d746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLAY_COUNT_INFINITE&#160;&#160;&#160;UINT32_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat Sequence or animation indefinitely. </p>

</div>
</div>
<a class="anchor" id="ga77075c217c0911bc6ea68dbdc73787e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PLAY_DURATION_INFINITE&#160;&#160;&#160;UINT32_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duration of Sequence or animation is infinite. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 12 2015 18:15:26 for Pebble SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
