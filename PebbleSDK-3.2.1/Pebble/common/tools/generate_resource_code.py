#!/usr/bin/env python

import argparse
import os
import struct

import stm32_crc

import generate_c_byte_array


def split_items(l, n):
    items = []
    for i in xrange(0, len(l), n):
        items.append(tuple(l[i:i+n]))
    return items

def codegen_timeline_resource_table(filename, timeline_resources):
    with open(filename, 'w') as output_file:
        output_file.write("""
//
// AUTOGENERATED BY tools/generate_resource_code.py
// DO NOT MODIFY
//

#include "resource/resource_ids.auto.h"
#include "resource/resource_static.h"

const uint32_t g_timeline_resources[][3] = {
""")
        for res in timeline_resources:
            output_file.write("   [{}] = {{ {}, {}, {} }},\n"
                              .format(res["id"],
                                      res["sizes"].get('tiny', 'RESOURCE_ID_INVALID'),
                                      res["sizes"].get('small', 'RESOURCE_ID_INVALID'),
                                      res["sizes"].get('large', 'RESOURCE_ID_INVALID')))

        output_file.write("""};
""")

def codegen_timeline_ids(filename, timeline_resources):
    with open(filename, 'w') as output_file:
        output_file.write("""
#pragma once

//
// AUTOGENERATED BY tools/generate_resource_code.py
// DO NOT MODIFY
//

typedef enum {
  TIMELINE_RESOURCE_INVALID = 0,
""")
        for res in timeline_resources:
            output_file.write("  TIMELINE_RESOURCE_{} = {},\n".format(res["name"], res["id"]))

        output_file.write("  NUM_TIMELINE_RESOURCES,\n")
        output_file.write("""} TimelineResourceId;
""")

################################################################################################
def cmd_resource_header(args):
    with open(args.output_header, 'w') as output_file:
        output_file.write("""
#pragma once

//
// AUTOGENERATED BY tools/generate_resource_code.py
// DO NOT MODIFY
//

#include <stdint.h>
#include "{resource_header}"
typedef enum {{
  INVALID_RESOURCE = 0,
  RESOURCE_ID_INVALID = 0,
  DEFAULT_MENU_ICON = 0, // Friendly synonym for use in `PBL_APP_INFO()` calls
""".format(resource_header=args.resource_include))
        for i, resource_name in enumerate(args.resource_name_list, start=1):
            output_file.write("  RESOURCE_ID_" + resource_name + ", // " + str(i) + "\n")
        if args.aliases:
            aliases = split_items(args.aliases, 2)
            for alias in aliases:
                output_file.write("  RESOURCE_ID_{0} = RESOURCE_ID_{1},\n".format(*alias))
        if args.invalids:
            for invalid_key in args.invalids:
                output_file.write("  RESOURCE_ID_{0} = INVALID_RESOURCE,\n".format(invalid_key))
        output_file.write("""
} ResourceId;
""")


################################################################################################
def cmd_resource_version(args):
    with open(args.data_file, 'rb') as f:
        crc = stm32_crc.crc32(f.read())

    with open(args.output_header, 'w') as output_file:
        output_file.write("""
#pragma once

//
// AUTOGENERATED BY tools/generate_resource_code.py
// DO NOT MODIFY
//

#include <stdint.h>
#include "{}"

static const ResourceVersion {} = {{
  .crc = {},
  .timestamp = {}
}};
""".format(args.resource_include,
           args.version_def_name, crc, args.timestamp))


################################################################################################
def cmd_font_key_header(args):
    with open(args.output_header, 'w') as output_file:
        output_file.write("""
#pragma once

//
// AUTOGENERATED BY tools/generate_resource_code.py
// DO NOT MODIFY
//

""")

        for key in args.resource_key_list:
            output_file.write("#define FONT_KEY_{key} \"RESOURCE_ID_{key}\"\n".format(key=key))

        # See PBL-9335. We removed this define as it's no longer a complete font. It looked the
        # same as Gothic 14, so going forward use that visual lookalike instead.
        output_file.write('#define FONT_KEY_FONT_FALLBACK "RESOURCE_ID_GOTHIC_14"\n');


################################################################################################
def cmd_font_key_table(args):
    with open(args.output_code_file, 'w') as output_file:
        output_file.write("""
//
// AUTOGENERATED BY tools/generate_resource_code.py
// DO NOT MODIFY
//

""")

        output_file.write('#include "%s"\n' % args.resource_id_header)
        output_file.write('#include "%s"\n' % args.font_key_header)

        output_file.write("""
static const struct {
  const char *key_name;
  ResourceId resource_id;
  ResourceId extension_id;
} s_font_resource_keys[] = {
""")

        for key in args.font_key_list:
            output_file.write("  {{ FONT_KEY_{key}, RESOURCE_ID_{key}, RESOURCE_ID_{key}_EXTENDED }},\n".format(key=key))

        output_file.write("};\n")


################################################################################################
def cmd_pfs_table_table(args):
    if (len(args.resource_data) % 4) is not 0:
        raise Exception ("resource_data must have a number of entries divisible by 4")

    with open(args.output_code_file, 'w') as output_file:
        output_file.write("""
//
// AUTOGENERATED BY tools/generate_resource_code.py
// DO NOT MODIFY
//

""")

        output_file.write('#include "%s"\n' % args.resource_id_header)
        output_file.write('#include "resource/resource_storage.h"\n')
        output_file.write('#include "resource/resource_storage_file.h"')

        output_file.write("""

const uint32_t g_num_file_resource_stores = {num_stores};

const FileResourceData g_file_resource_stores[] = {{
""".format(num_stores=(len(args.resource_data) / 4)))

        for i in range(0, len(args.resource_data), 4):
            (first_name, last_name, filename, id_offset) = args.resource_data[i:i+4]
            output_file.write('  {{ RESOURCE_ID_{first}, RESOURCE_ID_{last}, {id_offset}, "{filename}" }},\n'
                .format(first=first_name, last=last_name, filename=filename, id_offset=id_offset))

        output_file.write("};\n")


################################################################################################
def cmd_builtin_resources(args):
    tuple_size = 2
    if (len(args.resource_data) % tuple_size) is not 0:
        raise Exception ("resource_data must have a number of entries divisible by %u" % tuple_size)

    items = split_items(args.resource_data, tuple_size)

    with open(args.output_code_file, 'w') as output_file:
        output_file.write("\n//" \
                          "// AUTOGENERATED BY tools/generate_resource_code.py\n" \
                          "// DO NOT MODIFY\n"
                          "//\n\n")

        output_file.write('#include "%s"\n' % args.resource_id_header)
        output_file.write('#include "resource/resource_storage.h"\n')
        output_file.write('#include "resource/resource_storage_builtin.h"\n')
        output_file.write('#include <stdint.h>\n\n')

        def var_name(resource_id):
            return resource_id + '_builtin_bytes'

        # Write the blobs of data:
        for (input_path, resource_id) in items:
            with open(input_path, 'rb') as input_file:
                bytes = input_file.read()
                variable_name = var_name(resource_id)
                generate_c_byte_array.write(output_file, bytes, variable_name)

        # Write the index array:
        output_file.write("\nconst uint32_t g_num_builtin_resources = {num_items};\n\n" \
                          "const BuiltInResourceData g_builtin_resources[] = {{\n".format(num_items=len(items)))

        for (_, resource_id) in items:
            output_file.write('  {{ RESOURCE_ID_{resource_id}, {var_name}, sizeof({var_name}) }},\n'
                .format(resource_id=resource_id,
                        var_name=var_name(resource_id)))

        output_file.write("};\n")


################################################################################################
def main():
    parser = argparse.ArgumentParser(description="Generate the needed code to use resources")
    subparsers = parser.add_subparsers(help="commands", dest='which')

    resource_header_parser = subparsers.add_parser('resource_id_header',
        help="make the resource id file")
    resource_header_parser.add_argument('output_header', metavar="OUTPUT_HEADER",
        help="File to write to")
    resource_header_parser.add_argument('resource_include', metavar="RESOURCE_INCLUDE",
        help="Include path to insert into the output file")
    resource_header_parser.add_argument('resource_name_list', metavar="RESOURCE_NAME_LIST",
        help="list of defnames", nargs="*")
    resource_header_parser.add_argument('--aliases', metavar="RESOURCE_ALIASES_LIST",
        help="list of defname aliases", nargs="*")
    resource_header_parser.add_argument('--invalids', metavar="RESOURCE_INVALIDS_LIST",
        help="list of defnames that should be set to INVALID_RESOURCE", nargs="*")
    resource_header_parser.set_defaults(func=cmd_resource_header)

    resource_version_parser = subparsers.add_parser('resource_version_header',
        help="make the resource crc/version file")
    resource_version_parser.add_argument('version_def_name', metavar="VERSION_DEF_NAME",
        help="Name of the resource version")
    resource_version_parser.add_argument('output_header', metavar="OUTPUT_HEADER",
        help="File to write to")
    resource_version_parser.add_argument('timestamp', metavar="TIMESTAMP",
        help="Timestamp associated with this pack", type=int)
    resource_version_parser.add_argument('resource_include', metavar="RESOURCE_INCLUDE",
        help="Include path to insert into the output file")
    resource_version_parser.add_argument('data_file', metavar="DATA_FILE",
        help="The data chunk file")
    resource_version_parser.set_defaults(func=cmd_resource_version)

    font_key_header_parser = subparsers.add_parser('font_key_header', help="Make the font key header file")
    font_key_header_parser.add_argument('output_header', metavar="OUTPUT_HEADER", help="file to write to")
    font_key_header_parser.add_argument('resource_key_list', metavar="RESOURCE_KEY_LIST", help="List of resource IDs of fonts", nargs="*")
    font_key_header_parser.set_defaults(func=cmd_font_key_header)

    font_table_header_parser = subparsers.add_parser('font_key_table', help="Make the font key header file")
    font_table_header_parser.add_argument('output_code_file', metavar="OUTPUT_CODE_FILE", help="C file to write to")
    font_table_header_parser.add_argument('resource_id_header', metavar="resource_id_header", help="header to include to get the resource id's")
    font_table_header_parser.add_argument('font_key_header', metavar="font_key_header", help="header to include to get the font keys")
    font_table_header_parser.add_argument('font_key_list', metavar="FONT_KEY_LIST", help="List of resource def_names of fonts", nargs="*")
    font_table_header_parser.set_defaults(func=cmd_font_key_table)

    pfs_parser = subparsers.add_parser('pfs_files_header', help="make the pfs files header file")
    pfs_parser.add_argument('output_code_file', metavar="OUTPUT_CODE_FILE", help="C file to write to")
    pfs_parser.add_argument('resource_id_header', metavar="resource_id_header", help="header to include to get the resource id's")
    pfs_parser.add_argument('resource_data', metavar="RESOURCE_DATA", help="groups of <first name> <last name> <id_offset> <filename>", nargs="*")
    pfs_parser.set_defaults(func=cmd_pfs_table_table)

    builtin_parser = subparsers.add_parser('builtin_resources', help="make the builtin resources file")
    builtin_parser.add_argument('output_code_file', metavar="OUTPUT_CODE_FILE", help="C file to write to")
    builtin_parser.add_argument('resource_id_header', metavar="resource_id_header", help="header to include to get the resource id's")
    builtin_parser.add_argument('resource_data', metavar="RESOURCE_DATA", help="groups of <input_path> <resource_id>", nargs="*")
    builtin_parser.set_defaults(func=cmd_builtin_resources)

    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
